<html>
    <head>
        <style>
            #map {
                border: 2px solid black;
                float: left;
            }

            #map .cell {
                width: 40px;
                height: 40px;
                border: 2px solid black;
                display: inline-block;
            }

            #map .cell.junk {
                background-color: gold;
            }

            #map .cell.wall {
                background-color: #666;
            }

            #map .cell .player {
                border-radius: 50%;
                background-color: red;
                width: 50%;
                height: 50%;
                margin-top: 25%;
                margin-left: 25%;
            }

            #side {
                margin-left: 20px;
                float: left;
            }
        </style>
    </head>
    <body>
        <div id="container">
            <div id="map"></div>
            <div id="side">
                <div><h1>Score: <span id="score"></span>/<span id="max-score"></span></h4></div>
                <div><h1>Actions: <span id="actions-performed"></span></h4></div>               
            </div>
 
        </div>
        <script>
            (function() {
                function shouldOccur(probability) {
                    return probability > Math.random();
                }

                function Coordinate(x, y) {
                    return {
                        x: x,
                        y: y
                    };
                }

                var MAP_CELL_TYPE_FREE = "free";
                var MAP_CELL_TYPE_JUNK = "junk";
                var MAP_CELL_TYPE_WALL = "wall";

                function Map(size, junkProbability) {
                    var cells = [];

                    for (var i = 0; i < size; i++) {
                        cells[i] = [];

                        for (var j = 0; j < size; j++) {
                            var type = MAP_CELL_TYPE_FREE;

                            if (i === 0 || i === size - 1 || j === 0 || j === size - 1) {
                                type = MAP_CELL_TYPE_WALL;
                            } else if (shouldOccur(junkProbability)) {
                                type = MAP_CELL_TYPE_JUNK;
                            }

                            cells[i].push({
                                type: type
                            });
                        }
                    }

                    return {
                        width: size,
                        height: size,
                        junkProbability: junkProbability,
                        cells: cells
                    };
                }

                function getCellByCoordinate(map, coordinate) {
                    return map.cells[coordinate.y][coordinate.x];
                }

                function Game(map, startCoordinate) {
                    //TODO: clone map.
                    var currentCoordinate = startCoordinate;
                    getCellByCoordinate(map, currentCoordinate).type = MAP_CELL_TYPE_FREE;
                    var numJunkCells = map.cells.reduce(function (sum, row) {
                        return row.reduce(function (rowSum, cell) {
                            return rowSum + (cell.type === MAP_CELL_TYPE_JUNK ? 1 : 0);
                        }, sum);
                    }, 0);
                    var score = 0;
                    var actionsPerformed = 0;

                    function getScore() {
                        return score;
                    }

                    function getMaxScore() {
                        return numJunkCells;
                    }

                    function getActionsPerformed() {
                        return actionsPerformed;
                    }

                    function getCurrentPosition() {
                        return currentCoordinate;
                    }

                    function getCellType(coordinate) {
                        return getCellByCoordinate(map, coordinate).type;
                    }

                    function go(xDir, yDir) {
                        actionsPerformed++;
                        var newCoordinate = Coordinate(currentCoordinate.x + xDir, currentCoordinate.y + yDir);

                        var cell = getCellByCoordinate(map, newCoordinate);

                        if (cell.type === MAP_CELL_TYPE_JUNK) {
                            score++;
                            cell.type = MAP_CELL_TYPE_FREE;
                        } else if(cell.type === MAP_CELL_TYPE_WALL) {
                            return false;
                        }

                        currentCoordinate = newCoordinate;
                        return true;
                    }

                    return {
                        getScore: getScore,
                        getMaxScore: getMaxScore,
                        getActionsPerformed: getActionsPerformed,
                        getCurrentPosition: getCurrentPosition,
                        getCellType: getCellType,
                        map: map,
                        go: go
                    };
                }

                // View

                function View() {
                    function getElementByCoordinate(coordinate) {
                        return document.getElementById("map").childNodes[coordinate.y].childNodes[coordinate.x];
                    }

                    function renderMap(map) {
                        var mapElement = document.getElementById("map");
                        var fragment = document.createDocumentFragment();

                        map.cells.forEach(function iterateRows(row, x) {
                            var rowElement = document.createElement("div");
                            rowElement.className = "row";
                            row.forEach(function iterateCols(cell, y) {
                                var cellElement = document.createElement("div");
                                cellElement.className = "cell " + cell.type;
                                rowElement.appendChild(cellElement);
                            });
                            fragment.appendChild(rowElement);
                        });

                        mapElement.innerHTML = "";
                        mapElement.appendChild(fragment);
                    }

                    function renderGame(game) {
                        var playerCoordinate = game.getCurrentPosition();

                        renderMap(game.map);
                        var playerElement = getElementByCoordinate(playerCoordinate);
                        var playerMarkElement = document.createElement("div");
                        playerMarkElement.className = "player";
                        playerElement.appendChild(playerMarkElement);
                    }

                    function renderScore(game) {
                        var scoreElement = document.getElementById("score");
                        scoreElement.innerHTML = game.getScore();
                        var maxScoreElement = document.getElementById("max-score");
                        maxScoreElement.innerHTML = game.getMaxScore();
                    }

                    function renderActionsPerformed(game) {
                        var element = document.getElementById("actions-performed");
                        element.innerHTML = game.getActionsPerformed();
                    }

                    function registerActionListeners(game, onActionCallback) {
                        var KEY_LEFT_ARROW = 37;
                        var KEY_UP_ARROW = 38;
                        var KEY_RIGHT_ARROW = 39;
                        var KEY_DOWN_ARROW = 40;

                        var DELAY = 200;
                        var delayTimeout;
                        var firstKey;

                        function reset() {
                            firstKey = null;
                            delayTimeout = null;
                        }

                        function handleEvent(firstKey, secondKey) {
                            var xDir = 0;
                            var yDir = 0;

                            if (firstKey === secondKey || Math.abs(firstKey - secondKey) === 2) {
                                secondKey = null;
                            }

                            function updateDirection(key) {
                                if (key === KEY_LEFT_ARROW) {
                                    xDir = -1;
                                } else if (key === KEY_UP_ARROW) {
                                    yDir = -1;
                                } else if (key === KEY_RIGHT_ARROW) {
                                    xDir = 1;
                                } else if (key === KEY_DOWN_ARROW) {
                                    yDir = 1;
                                }
                            }

                            updateDirection(firstKey);
                            updateDirection(secondKey);

                            if (!xDir && !yDir) {
                                return false;
                            }

                            game.go(xDir, yDir);
                            onActionCallback();
                            return true;
                        }

                        document.addEventListener("keydown", function(event) {
                            if (firstKey) {
                                clearTimeout(delayTimeout);
                                handleEvent(firstKey, event.keyCode);
                                reset();
                                return;
                            }

                            //TODO: Remove this for delay which supports diagonal play.
                            if (!handleEvent(event.keyCode)) {
                                event.preventDefault();
                            }
                            event.preventDefault();
                            return false;

                            firstKey = event.keyCode;
                            delayTimeout = setTimeout(function onDelayTimeout() {
                                handleEvent(firstKey);
                                reset();
                            }, DELAY);
                        });
                    }

                    function run(game) {
                        function render() {
                            renderGame(game);
                            renderScore(game);
                            renderActionsPerformed(game);
                        }

                        render();
                        registerActionListeners(game, function onAction() {
                            render();
                        });
                    }

                    return {
                        run: run
                    };
                }

                // Run

                var map = Map(10, 0.1);

                var game = Game(map, Coordinate(1, 1));

                var view = View();
                view.run(game);
            })();
        </script>
    </body>
</html>